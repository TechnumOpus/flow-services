package com.onified.distribute.controller;

import com.onified.distribute.dto.InventoryOrderPipelineDTO;
import com.onified.distribute.dto.ReplenishmentQueueDTO;
import com.onified.distribute.repository.ConsumptionProfileRepository;
import com.onified.distribute.repository.LeadTimeRepository;
import com.onified.distribute.repository.ProductRepository;
import com.onified.distribute.service.ReplenishmentQueueService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestController
@RequestMapping("/api/v1/replenishment-queue")
@RequiredArgsConstructor
public class ReplenishmentQueueController {

    private final ReplenishmentQueueService replenishmentQueueService;
    private final ConsumptionProfileRepository consumptionProfileRepository;
    private final LeadTimeRepository leadTimeRepository;
    private final ProductRepository productRepository;



    @PostMapping("/process")
    public ResponseEntity<Void> processReplenishmentQueue() {
        log.info("Processing replenishment queue");
        replenishmentQueueService.processReplenishmentQueue();
        return ResponseEntity.ok().build();
    }

    @GetMapping("/in-transit/{locationId}")
    public ResponseEntity<Page<InventoryOrderPipelineDTO>> getInTransitOrders(
            @PathVariable String locationId, Pageable pageable) {
        log.info("Fetching in-transit orders for location: {}", locationId);
        Page<InventoryOrderPipelineDTO> orders = replenishmentQueueService.getInTransitOrders(locationId, pageable);
        return ResponseEntity.ok(orders);
    }

    @DeleteMapping("/orders/{orderId}")
    public ResponseEntity<Void> cancelOrder(@PathVariable String orderId) {
        log.info("Canceling order: {}", orderId);
        replenishmentQueueService.cancelOrder(orderId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/generate")
    public ResponseEntity<String> generateDailyReplenishmentQueue() {
        log.info("Generating daily replenishment queue");
        try {
            replenishmentQueueService.generateDailyReplenishmentQueue();
            return ResponseEntity.ok("Daily replenishment queue generated successfully");
        } catch (Exception e) {
            log.error("Error generating daily replenishment queue", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Failed to generate daily replenishment queue: " + e.getMessage());
        }
    }
    @PostMapping
    public ResponseEntity<ReplenishmentQueueDTO> createQueueItem(@Valid @RequestBody ReplenishmentQueueDTO queueDTO) {
        log.info("Creating replenishment queue item with ID: {}", queueDTO.getQueueId());
        ReplenishmentQueueDTO createdQueueItem = replenishmentQueueService.createQueueItem(queueDTO);
        return new ResponseEntity<>(createdQueueItem, HttpStatus.CREATED);
    }

    @PutMapping("/{queueId}")
    public ResponseEntity<ReplenishmentQueueDTO> updateQueueItem(
            @PathVariable String queueId,
            @Valid @RequestBody ReplenishmentQueueDTO queueDTO) {
        log.info("Updating replenishment queue item: {}", queueId);
        ReplenishmentQueueDTO updatedQueueItem = replenishmentQueueService.updateQueueItem(queueId, queueDTO);
        return ResponseEntity.ok(updatedQueueItem);
    }

    @GetMapping("/{queueId}")
    public ResponseEntity<ReplenishmentQueueDTO> getQueueItemById(@PathVariable String queueId) {
        log.info("Fetching replenishment queue item: {}", queueId);
        ReplenishmentQueueDTO queueItem = replenishmentQueueService.getQueueItemById(queueId);
        return ResponseEntity.ok(queueItem);
    }

    @GetMapping("/by-status")
    public ResponseEntity<Page<ReplenishmentQueueDTO>> getQueueItemsByStatus(
            @RequestParam String status,
            Pageable pageable) {
        log.info("Fetching queue items by status: {}", status);
        Page<ReplenishmentQueueDTO> queueItems = replenishmentQueueService.getQueueItemsByStatus(status, pageable);
        return ResponseEntity.ok(queueItems);
    }

    @GetMapping("/by-zone-and-status")
    public ResponseEntity<Page<ReplenishmentQueueDTO>> getQueueItemsByBufferZoneAndStatus(
            @RequestParam String bufferZone,
            @RequestParam String status,
            Pageable pageable) {
        log.info("Fetching queue items by buffer zone: {} and status: {}", bufferZone, status);
        Page<ReplenishmentQueueDTO> queueItems = replenishmentQueueService.getQueueItemsByBufferZoneAndStatus(bufferZone, status, pageable);
        return ResponseEntity.ok(queueItems);
    }


    @GetMapping("/debug/data-check/{productId}/{locationId}")
    public ResponseEntity<Map<String, Object>> debugDataCheck(
            @PathVariable String productId,
            @PathVariable String locationId) {

        Map<String, Object> result = new HashMap<>();

        // Check ConsumptionProfile
        var consumptionProfile = consumptionProfileRepository
                .findByProductIdAndLocationId(productId, locationId);
        result.put("consumptionProfileExists", consumptionProfile.isPresent());
        if (consumptionProfile.isPresent()) {
            result.put("adcNormalized", consumptionProfile.get().getAdcNormalized());
        }

        // Check LeadTime
        var leadTime = leadTimeRepository
                .findByProductIdAndLocationIdAndIsActive(productId, locationId, true);
        result.put("leadTimeExists", leadTime.isPresent());
        if (leadTime.isPresent()) {
            result.put("bufferLeadTimeDays", leadTime.get().getBufferLeadTimeDays());
        }

        // Check Product
        var product = productRepository.findByProductId(productId);
        result.put("productExists", product.isPresent());
        if (product.isPresent()) {
            result.put("moq", product.get().getMoq());
        }

        return ResponseEntity.ok(result);
    }

}
