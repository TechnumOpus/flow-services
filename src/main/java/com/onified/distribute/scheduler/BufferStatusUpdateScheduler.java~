package com.onified.distribute.scheduler;

import com.onified.distribute.entity.InventoryBuffer;
import com.onified.distribute.entity.InventoryOrderPipeline;
import com.onified.distribute.repository.DailyConsumptionLogRepository;
import com.onified.distribute.repository.InventoryBufferRepository;
import com.onified.distribute.repository.InventoryOrderPipelineRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class BufferStatusUpdateScheduler {

    private final InventoryBufferRepository inventoryBufferRepository;
    private final InventoryOrderPipelineRepository inventoryOrderPipelineRepository;
    private final DailyConsumptionLogRepository dailyConsumptionLogRepository;
    // Run every hour during business hours (9 AM to 6 PM)
    @Scheduled(cron = "0 0 9-18 * * MON-FRI")
    @Transactional
    public void updateBufferStatusForAllLocations() {
        log.info("Starting scheduled buffer status update for all locations");

        try {
            // Get all unique location IDs from active buffers
            Set<String> locationIds = getAllActiveLocationIds();
            log.info("Found {} unique locations with active buffers", locationIds.size());

            int totalProcessed = 0;
            int totalUpdated = 0;
            int totalErrors = 0;

            for (String locationId : locationIds) {
                try {
                    BufferUpdateResult result = updateBufferStatusForLocation(locationId);
                    totalProcessed += result.getProcessedCount();
                    totalUpdated += result.getUpdatedCount();
                    totalErrors += result.getErrorCount();

                    log.info("Location {}: Processed={}, Updated={}, Errors={}",
                            locationId, result.getProcessedCount(), result.getUpdatedCount(), result.getErrorCount());

                } catch (Exception e) {
                    log.error("Failed to update buffer status for location: {}, error: {}", locationId, e.getMessage(), e);
                    totalErrors++;
                }
            }

            log.info("Completed scheduled buffer status update - Total Processed: {}, Updated: {}, Errors: {}",
                    totalProcessed, totalUpdated, totalErrors);

        } catch (Exception e) {
            log.error("Error in scheduled buffer status update: {}", e.getMessage(), e);
        }
    }

    // Run every 4 hours to check for critical buffers
    @Scheduled(fixedRate = 14400000) // 4 hours in milliseconds
    @Transactional(readOnly = true)
    public void monitorCriticalBuffers() {
        log.info("Starting critical buffer monitoring");

        try {
            // Find buffers in RED and CRITICAL zones
            List<String> criticalZones = Arrays.asList("RED", "CRITICAL");
            Pageable pageable = PageRequest.of(0, 1000); // Process in batches

            Page<InventoryBuffer> criticalBuffers = inventoryBufferRepository.findByCurrentZoneIn(criticalZones, pageable);

            if (criticalBuffers.hasContent()) {
                log.warn("Found {} critical buffers requiring attention", criticalBuffers.getTotalElements());

                // Group by location for better reporting
                Map<String, List<InventoryBuffer>> buffersByLocation = criticalBuffers.getContent()
                        .stream()
                        .collect(Collectors.groupingBy(InventoryBuffer::getLocationId));

                buffersByLocation.forEach((locationId, buffers) -> {
                    log.warn("Location {}: {} critical buffers - Products: {}",
                            locationId,
                            buffers.size(),
                            buffers.stream().map(InventoryBuffer::getProductId).collect(Collectors.toList()));
                });

                // Here you could send alerts, notifications, or trigger automated replenishment
                // For example: alertService.sendCriticalBufferAlert(criticalBuffers);
            } else {
                log.info("No critical buffers found - all buffers are in healthy zones");
            }

        } catch (Exception e) {
            log.error("Error in critical buffer monitoring: {}", e.getMessage(), e);
        }
    }

    /**
     * Update buffer status for a specific location
     */
    @Transactional
    public BufferUpdateResult updateBufferStatusForLocation(String locationId) {
        log.info("Updating buffer status for location: {}", locationId);
        BufferUpdateResult result = new BufferUpdateResult();

        try {
            // DEBUG: First check if any documents exist for this location
            Page<InventoryBuffer> allBuffersForLocation = inventoryBufferRepository
                    .findAllByLocationIdDebug(locationId, PageRequest.of(0, 1000));
            log.debug("DEBUG: Found {} total buffers for location: {} (ignoring is_active)",
                    allBuffersForLocation.getContent().size(), locationId);

            // DEBUG: Log the is_active values
            allBuffersForLocation.getContent().forEach(buffer ->
                    log.debug("DEBUG: Buffer {}, isActive: {}", buffer.getBufferId(), buffer.getIsActive()));

            // Original query
            Page<InventoryBuffer> buffersPage = inventoryBufferRepository
                    .findActiveBuffersByLocationId(locationId, PageRequest.of(0, 1000));
            List<InventoryBuffer> buffers = buffersPage.getContent();

            log.debug("Found {} active buffers for location: {}", buffers.size(), locationId);

            if (buffers.isEmpty()) {
                log.info("No active buffers found for location: {}", locationId);
                return result;
            }

            // Log buffer IDs for debugging
            buffers.forEach(buffer -> log.debug("Processing buffer: {}, product: {}, isActive: {}",
                    buffer.getBufferId(), buffer.getProductId(), buffer.getIsActive()));

            // Step 2: Get pipeline quantities for all products at this location
            Map<String, Integer> pipelineQuantities = calculatePipelineQuantities(locationId);

            // Step 3: Process each buffer
            for (InventoryBuffer buffer : buffers) {
                try {
                    boolean updated = updateBufferMetrics(buffer, pipelineQuantities);
                    result.incrementProcessed();
                    if (updated) {
                        result.incrementUpdated();
                    }
                } catch (Exception e) {
                    log.error("Error updating buffer {}: {}", buffer.getBufferId(), e.getMessage(), e);
                    result.incrementError();
                }
            }

            log.info("Completed buffer status update for location: {} - Processed: {}, Updated: {}, Errors: {}",
                    locationId, result.getProcessedCount(), result.getUpdatedCount(), result.getErrorCount());

        } catch (Exception e) {
            log.error("Error updating buffer status for location {}: {}", locationId, e.getMessage(), e);
            result.incrementError();
        }

        return result;
    }



    /**
     * Calculate pipeline quantities for all products at a location
     */
    private Map<String, Integer> calculatePipelineQuantities(String locationId) {
        log.debug("Starting pipeline calculation for location: {}", locationId);


        List<String> pipelineStatuses = Arrays.asList("CONFIRMED", "SHIPPED", "IN_TRANSIT");
        Map<String, Integer> pipelineQuantities = new HashMap<>();

        for (String status : pipelineStatuses) {
            try {
                log.debug("Checking pipeline orders with status: {} for location: {}", status, locationId);

                Page<InventoryOrderPipeline> ordersPage = inventoryOrderPipelineRepository
                        .findByStatusAndLocationId(status, locationId, PageRequest.of(0, 1000));

                log.debug("Found {} orders with status: {} for location: {}",
                        ordersPage.getContent().size(), status, locationId);

                ordersPage.getContent().forEach(order -> {
                    String productId = order.getProductId();
                    Integer pendingQty = order.getPendingQty() != null ? order.getPendingQty() : 0;

                    // CORRECTED: Only add positive quantities to pipeline
                    if (pendingQty > 0) {
                        pipelineQuantities.merge(productId, pendingQty, Integer::sum);

                        log.debug("Added to pipeline - Order: {}, Product: {}, Qty: {}, Total for product: {}",
                                order.getOrderId(), productId, pendingQty, pipelineQuantities.get(productId));
                    }
                });

            } catch (Exception e) {
                log.error("Error calculating pipeline quantities for status {} at location {}: {}",
                        status, locationId, e.getMessage(), e);
            }
        }

        log.info("Final calculated pipeline quantities for location {}: {}", locationId, pipelineQuantities);
        return pipelineQuantities;
    }


    /**
     * Update metrics for a single buffer
     */
    /**
     * Update metrics for a single buffer
     */
    private boolean updateBufferMetrics(InventoryBuffer buffer, Map<String, Integer> pipelineQuantities) {
        String productId = buffer.getProductId();
        Integer pipelineQty = pipelineQuantities.getOrDefault(productId, 0);

        log.debug("Starting buffer metrics update for buffer: {}, product: {}",
                buffer.getBufferId(), productId);

        // Get current_inventory from daily_consumption_log or warehouse data
        Integer currentInventory = getCurrentInventory(buffer);
        if (currentInventory == null || currentInventory < 0) {
            log.warn("Invalid current_inventory for buffer {}: {}. Using 0.", buffer.getBufferId(), currentInventory);
            currentInventory = 0;
        }

        // Store original values for comparison
        String originalZone = buffer.getCurrentZone();
        Integer originalConsecutiveDays = buffer.getConsecutiveZoneDays() != null ? buffer.getConsecutiveZoneDays() : 0;
        Integer originalPipelineQty = buffer.getInPipelineQty();
        Integer originalNetAvailableQty = buffer.getNetAvailableQty();
        Double originalBufferConsumedPct = buffer.getBufferConsumedPct();

        log.debug("Original values for buffer {}: pipeline_qty={}, net_available_qty={}, buffer_consumed_pct={}",
                buffer.getBufferId(), originalPipelineQty, originalNetAvailableQty, originalBufferConsumedPct);

        // Update pipeline quantity
        buffer.setInPipelineQty(pipelineQty);
        log.debug("Updated in_pipeline_qty for buffer {}: {} -> {}",
                buffer.getBufferId(), originalPipelineQty, pipelineQty);

        // Calculate net available quantity
        Integer netAvailableQty = currentInventory + pipelineQty;
        buffer.setNetAvailableQty(netAvailableQty);
        log.debug("Updated net_available_qty for buffer {}: {} -> {} (current_inventory: {} + in_pipeline_qty: {})",
                buffer.getBufferId(), originalNetAvailableQty, netAvailableQty, currentInventory, pipelineQty);

        // Calculate buffer consumed percentage
        Double bufferConsumedPct = calculateBufferConsumedPct(buffer, netAvailableQty);
        buffer.setBufferConsumedPct(bufferConsumedPct);

        // Fix the log formatting - use String.format instead of log placeholders for percentage
        double originalPct = originalBufferConsumedPct != null ? originalBufferConsumedPct : 0.0;
        log.debug("Updated buffer_consumed_pct for buffer {}: {}% -> {}%",
                buffer.getBufferId(),
                String.format("%.2f", originalPct),
                String.format("%.2f", bufferConsumedPct));

        // Determine current zone
        String newZone = determineBufferZone(buffer, bufferConsumedPct);
        buffer.setCurrentZone(newZone);

        // Update consecutive zone days
        updateConsecutiveZoneDays(buffer, originalZone, newZone, originalConsecutiveDays);

        // Update timestamp
        buffer.setUpdatedAt(LocalDateTime.now());
        buffer.setUpdatedBy("SYSTEM_SCHEDULER");

        // Save the updated buffer
        try {
            log.debug("Saving buffer {} with updated values...", buffer.getBufferId());
            InventoryBuffer savedBuffer = inventoryBufferRepository.save(buffer);

            // Fix the log formatting here too
            log.info("Successfully saved buffer {}: in_pipeline_qty={}, net_available_qty={}, buffer_consumed_pct={}%, current_zone={}",
                    savedBuffer.getBufferId(),
                    savedBuffer.getInPipelineQty(),
                    savedBuffer.getNetAvailableQty(),
                    String.format("%.2f", savedBuffer.getBufferConsumedPct()),
                    savedBuffer.getCurrentZone());

            // Verify the save worked by checking what was actually saved
            Optional<InventoryBuffer> verifyBuffer = inventoryBufferRepository.findById(savedBuffer.getId());
            if (verifyBuffer.isPresent()) {
                InventoryBuffer verified = verifyBuffer.get();
                log.debug("Verification - Buffer {} saved values: in_pipeline_qty={}, net_available_qty={}, buffer_consumed_pct={}%",
                        verified.getBufferId(),
                        verified.getInPipelineQty(),
                        verified.getNetAvailableQty(),
                        String.format("%.2f", verified.getBufferConsumedPct()));
            }

        } catch (Exception e) {
            log.error("Failed to save buffer {}: {}", buffer.getBufferId(), e.getMessage(), e);
            return false;
        }

        // Log significant changes
        if (!Objects.equals(originalZone, newZone)) {
            log.info("Buffer zone changed - Buffer: {}, Product: {}, Location: {}, {} -> {}, Consumed: {}%",
                    buffer.getBufferId(), productId, buffer.getLocationId(),
                    originalZone, newZone, String.format("%.1f", bufferConsumedPct));
        }

        return true; // Indicate that update was performed
    }


    /**
     * Get current inventory from daily_consumption_log or warehouse data
     */
    private Integer getCurrentInventory(InventoryBuffer buffer) {
        String productId = buffer.getProductId();
        String locationId = buffer.getLocationId();
        String bufferId = buffer.getBufferId();

        // Get base inventory from buffer (this should be the initial/last known inventory)
        Integer baseInventory = buffer.getCurrentInventory();
        if (baseInventory == null) {
            log.warn("No base current_inventory found for buffer {}. Using 0.", bufferId);
            baseInventory = 0;
        }

        // Query daily_consumption_log for consumption since last update
        // CORRECTED: Should get consumption since last buffer update, not arbitrary 30 days
        LocalDateTime lastUpdate = buffer.getUpdatedAt() != null ? buffer.getUpdatedAt() : LocalDateTime.now().minusDays(1);

        log.debug("Querying consumption data for buffer {} since last update: {}", bufferId, lastUpdate);

        Integer consumedSinceLastUpdate = dailyConsumptionLogRepository.sumQuantityConsumed(productId, locationId, lastUpdate);
        if (consumedSinceLastUpdate == null) {
            consumedSinceLastUpdate = 0;
        }

        // CORRECTED FORMULA: Current Inventory = Base Inventory - Consumed Quantity
        // (consumption should reduce available inventory)
        int currentInventory = baseInventory - consumedSinceLastUpdate;

        // Ensure non-negative inventory
        if (currentInventory < 0) {
            log.warn("Negative inventory calculated for buffer {}: {}. Setting to 0.", bufferId, currentInventory);
            currentInventory = 0;
        }

        log.debug("Calculated current_inventory for buffer {}: base={}, consumed_since_update={}, current={}",
                bufferId, baseInventory, consumedSinceLastUpdate, currentInventory);

        return currentInventory;
    }


    /**
     * Calculate buffer consumed percentage
     */
    private Double calculateBufferConsumedPct(InventoryBuffer buffer, Integer netAvailableQty) {
        Integer bufferUnits = buffer.getBufferUnits();

        if (bufferUnits == null || bufferUnits <= 0) {
            log.warn("Invalid buffer units for buffer {}: {}", buffer.getBufferId(), bufferUnits);
            return 0.0;
        }

        // Buffer consumed % = (1 - net_available_qty / buffer_units) * 100
        double consumedPct = (1.0 - (double) netAvailableQty / bufferUnits) * 100;

        // Ensure percentage is between 0 and 100
        return Math.max(0.0, Math.min(100.0, consumedPct));
    }

    /**
     * Determine buffer zone based on consumed percentage and thresholds
     */
    private String determineBufferZone(InventoryBuffer buffer, Double bufferConsumedPct) {
        Double redThreshold = buffer.getRedThresholdPct() != null ? buffer.getRedThresholdPct() : 33.0;
        Double yellowThreshold = buffer.getYellowThresholdPct() != null ? buffer.getYellowThresholdPct() : 33.0;

        // LOGIC: Higher consumed percentage means more critical
        // RED = Most critical (high consumption)
        // YELLOW = Warning (moderate consumption)
        // GREEN = Safe (low consumption)

        if (bufferConsumedPct >= redThreshold) {
            return "RED";       // Critical: Buffer is highly consumed
        } else if (bufferConsumedPct >= yellowThreshold) {
            return "YELLOW";    // Warning: Buffer is moderately consumed
        } else {
            return "GREEN";     // Safe: Buffer has plenty available
        }
    }

    /**
     * Update consecutive zone days tracking
     */
    private void updateConsecutiveZoneDays(InventoryBuffer buffer, String originalZone,
                                           String newZone, Integer originalConsecutiveDays) {

        // CORRECTED: Handle null original zone (first time update)
        if (originalZone == null) {
            buffer.setConsecutiveZoneDays(1);
            log.debug("First zone assignment for buffer {}: {} (consecutive days = 1)",
                    buffer.getBufferId(), newZone);
            return;
        }

        if (Objects.equals(originalZone, newZone)) {
            // Same zone, increment consecutive days
            int newConsecutiveDays = (originalConsecutiveDays != null ? originalConsecutiveDays : 0) + 1;
            buffer.setConsecutiveZoneDays(newConsecutiveDays);
            log.debug("Zone unchanged for buffer {}: {} (consecutive days = {})",
                    buffer.getBufferId(), newZone, newConsecutiveDays);
        } else {
            // Zone changed, reset consecutive days to 1
            buffer.setConsecutiveZoneDays(1);
            log.info("Zone changed for buffer {}: {} -> {} (consecutive days reset to 1)",
                    buffer.getBufferId(), originalZone, newZone);
        }
    }

    /**
     * Get all unique location IDs that have active buffers
     */
    private Set<String> getAllActiveLocationIds() {
        Page<InventoryBuffer> activeBuffers = inventoryBufferRepository.findActiveBuffers(PageRequest.of(0, 10000));

        Set<String> locationIds = activeBuffers.getContent().stream()
                .map(InventoryBuffer::getLocationId)
                .collect(Collectors.toSet());

        log.debug("Active location IDs: {}", locationIds);
        return locationIds;
    }

    /**
     * Result class to track update statistics
     */
    public static class BufferUpdateResult {
        private int processedCount = 0;
        private int updatedCount = 0;
        private int errorCount = 0;

        public void incrementProcessed() { this.processedCount++; }
        public void incrementUpdated() { this.updatedCount++; }
        public void incrementError() { this.errorCount++; }

        public int getProcessedCount() { return processedCount; }
        public int getUpdatedCount() { return updatedCount; }
        public int getErrorCount() { return errorCount; }
    }
}